#include <string>
#include <vector>

// -------------------------------------------------------------------------------------------------------------------------------------
// This is a test version of a template file that should be generated automatically by M3D Visual Studio Extension.
// The purpouse of the file is to provide a simple interface between the .dll file and the engine framework.
// This file was not generated by the extension, but it was written by me (Krzysztof) to test the interface.
// -------------------------------------------------------------------------------------------------------------------------------------

#define EXPORT __declspec(dllexport) __cdecl

#pragma region Managed code: External functions declarations

//This part of code should be managed by M3D Visual Studio Extension
extern void EXPORT function1();
extern void EXPORT function2();

#pragma endregion

#pragma region Data types definitions

namespace m3d
{
	class UFctSender;
	class UFctData;
}

namespace m3dfw
{
	class UFctInfo;
}

typedef void(__cdecl * UserFct_ptr)(m3d::UFctSender&, const m3d::UFctData&);
typedef void(__cdecl * VecUFct_ptr)(std::vector<m3dfw::UFctInfo>&);

namespace m3dfw
{
	class UFctInfo
	{
	public:

		UFctInfo() {}
		UFctInfo(const std::string & n, UserFct_ptr ptr) : name(n), pointer(ptr) {}

		std::string name;
		UserFct_ptr pointer;
	};
}

namespace m3d
{
	//TODO: Write these classes

	class UFctSender {};
	class UFctData {};
}

#pragma endregion

#pragma region Managed code: External function listing

//This part of code should be managed by M3D Visual Studio Extension

void getFctPtrList(std::vector<m3dfw::UFctInfo> & data)
{
	data.push_back(m3dfw::UFctInfo("function1", (UserFct_ptr)function1));
	data.push_back(m3dfw::UFctInfo("function2", (UserFct_ptr)function2));
}

#pragma endregion